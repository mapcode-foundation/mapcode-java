<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Point.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Mapcode Java Library</a> &gt; <a href="index.source.html" class="el_package">com.mapcode</a> &gt; <span class="el_source">Point.java</span></div><h1>Point.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2014-2016 Stichting Mapcode Foundation (http://www.mapcode.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.mapcode;

import javax.annotation.Nonnull;
import java.util.Arrays;
import java.util.Random;

import static com.mapcode.CheckArgs.checkNonnull;

/**
 * This class defines a class for lat/lon points.
 *
 * Internally, the class implements a fixed-point representation where a coordinate is expressed in
 * &quot;fractions&quot;, of 1/3.240,000,000,000th of a degree. A double (an IEEE 754-1985 binary64) is just
 * sufficient to represent coordinates between -180 and +180 degrees in such fractions.
 * However, for applications that use micro-degrees a lot, the implementation below is more efficient.
 * It represent the fractions in pairs of integers, the first integer
 * representing 1/1,000,000th of degrees, the second representing the remainder.
 */
<span class="pc bpc" id="L35" title="1 of 2 branches missed.">public class Point {</span>

    // Latitude and longitude ranges.
    public static final double LON_DEG_MIN = -180.0;
    public static final double LON_DEG_MAX = 180.0;
    public static final double LAT_DEG_MIN = -90.0;
    public static final double LAT_DEG_MAX = 90.0;

    // Conversion constants.
    public static final int DEG_TO_MICRO_DEG = 1000000;
    public static final int MICRO_DEG_90 = 90 * DEG_TO_MICRO_DEG;
    public static final int MICRO_DEG_180 = 180 * DEG_TO_MICRO_DEG;
    public static final int MICRO_DEG_360 = 360 * DEG_TO_MICRO_DEG;

    // Radius of Earth.
    public static final double EARTH_RADIUS_X_METERS = 6378137.0;
    public static final double EARTH_RADIUS_Y_METERS = 6356752.3;

    // Circumference of Earth.
    public static final double EARTH_CIRCUMFERENCE_X = EARTH_RADIUS_X_METERS * 2.0 * Math.PI;
    public static final double EARTH_CIRCUMFERENCE_Y = EARTH_RADIUS_Y_METERS * 2.0 * Math.PI;

    // Meters per degree latitude is fixed. For longitude: use factor * cos(midpoint of two degree latitudes).
    public static final double METERS_PER_DEGREE_LAT = EARTH_CIRCUMFERENCE_Y / 360.0;
    public static final double METERS_PER_DEGREE_LON_EQUATOR = EARTH_CIRCUMFERENCE_X / 360.0; // * cos(deg(lat)).

    /**
     * Create a point from lat/lon in degrees (may be precision!)
     *
     * @param latDeg Latitude in degrees. Range: [-90, 90].
     * @param lonDeg Longitude in degrees. Range: [-180, 180).
     * @return A defined point.
     */
    @Nonnull
    public static Point fromDeg(final double latDeg, final double lonDeg) {
<span class="fc" id="L70">        return new Point(latDeg, lonDeg);</span>
    }

    /**
     * Public construction, from integer microdegrees (no loss of precision).
     *
     * @param latMicroDeg Latitude, in microdegrees.
     * @param lonMicroDeg Longitude, in microdegrees.
     * @return A defined point.
     */
    @Nonnull
    public static Point fromMicroDeg(final int latMicroDeg, final int lonMicroDeg) {
<span class="fc" id="L82">        final Point p = new Point();</span>
<span class="fc" id="L83">        p.latMicroDeg = latMicroDeg;</span>
<span class="fc" id="L84">        p.latFractionOnlyDeg = 0;</span>
<span class="fc" id="L85">        p.lonMicroDeg = lonMicroDeg;</span>
<span class="fc" id="L86">        p.lonFractionOnlyDeg = 0;</span>
<span class="fc" id="L87">        p.defined = true;</span>
<span class="fc" id="L88">        return p.wrap();</span>
    }

    /**
     * Get the latitude in degrees (may lose precision).
     *
     * @return Latitude in degrees. No range is enforced.
     */
    public double getLatDeg() {
<span class="pc bpc" id="L97" title="2 of 4 branches missed.">        assert defined;</span>
<span class="fc" id="L98">        return (latMicroDeg / MICRODEG_TO_DEG_FACTOR) + (latFractionOnlyDeg / LAT_TO_FRACTIONS_FACTOR);</span>
    }

    /**
     * Get the longitude in degrees (may lose precision).
     *
     * @return Longitude in degrees. No range is enforced.
     */
    public double getLonDeg() {
<span class="pc bpc" id="L107" title="2 of 4 branches missed.">        assert defined;</span>
<span class="fc" id="L108">        return (lonMicroDeg / MICRODEG_TO_DEG_FACTOR) + (lonFractionOnlyDeg / LON_TO_FRACTIONS_FACTOR);</span>
    }

    /**
     * Get latitude as micro-degrees. Note that this looses precision beyond microdegrees!
     *
     * @return floor(Latitude in microdegrees)
     */
    public int getLatMicroDeg() {
<span class="pc bpc" id="L117" title="2 of 4 branches missed.">        assert defined;</span>
<span class="fc" id="L118">        return latMicroDeg;</span>
    }

    /**
     * Get longitude as micro-degrees. Note that this looses precision beyond microdegrees!
     *
     * @return floor(Longitude in microdegrees)
     */
    public int getLonMicroDeg() {
<span class="pc bpc" id="L127" title="2 of 4 branches missed.">        assert defined;</span>
<span class="fc" id="L128">        return lonMicroDeg;</span>
    }

    /**
     * Create a random point, uniformly distributed over the surface of the Earth.
     *
     * @param randomGenerator Random generator used to create a point.
     * @return Random point with uniform distribution over the sphere.
     */
    @Nonnull
    public static Point fromUniformlyDistributedRandomPoints(@Nonnull final Random randomGenerator) {
<span class="fc" id="L139">        checkNonnull(&quot;randomGenerator&quot;, randomGenerator);</span>

        // Calculate uniformly distributed 3D point on sphere (radius = 1.0):
        // http://mathproofs.blogspot.co.il/2005/04/uniform-random-distribution-on-sphere.html
<span class="fc" id="L143">        final double unitRand1 = randomGenerator.nextDouble();</span>
<span class="fc" id="L144">        final double unitRand2 = randomGenerator.nextDouble();</span>
<span class="fc" id="L145">        final double theta0 = (2.0 * Math.PI) * unitRand1;</span>
<span class="fc" id="L146">        final double theta1 = Math.acos(1.0 - (2.0 * unitRand2));</span>
<span class="fc" id="L147">        final double x = Math.sin(theta0) * Math.sin(theta1);</span>
<span class="fc" id="L148">        final double y = Math.cos(theta0) * Math.sin(theta1);</span>
<span class="fc" id="L149">        final double z = Math.cos(theta1);</span>

        // Convert Carthesian 3D point into lat/lon (radius = 1.0):
        // http://stackoverflow.com/questions/1185408/converting-from-longitude-latitude-to-cartesian-coordinates
<span class="fc" id="L153">        final double latRad = Math.asin(z);</span>
<span class="fc" id="L154">        final double lonRad = Math.atan2(y, x);</span>

        // Convert radians to degrees.
<span class="pc bpc" id="L157" title="2 of 4 branches missed.">        assert !Double.isNaN(latRad);</span>
<span class="pc bpc" id="L158" title="2 of 4 branches missed.">        assert !Double.isNaN(lonRad);</span>
<span class="fc" id="L159">        final double lat = latRad * (180.0 / Math.PI);</span>
<span class="fc" id="L160">        final double lon = lonRad * (180.0 / Math.PI);</span>
<span class="fc" id="L161">        return fromDeg(lat, lon);</span>
    }

    /**
     * Calculate the distance between two points. This algorithm does not take the curvature of the Earth into
     * account, so it only works for small distance up to, say 200 km, and not too close to the poles.
     *
     * @param p1 Point 1.
     * @param p2 Point 2.
     * @return Straight distance between p1 and p2. Only accurate for small distances up to 200 km.
     */
    public static double distanceInMeters(@Nonnull final Point p1, @Nonnull final Point p2) {
<span class="fc" id="L173">        checkNonnull(&quot;p1&quot;, p1);</span>
<span class="fc" id="L174">        checkNonnull(&quot;p2&quot;, p2);</span>

        final Point from;
        final Point to;
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (p1.getLonDeg() &lt;= p2.getLonDeg()) {</span>
<span class="fc" id="L179">            from = p1;</span>
<span class="fc" id="L180">            to = p2;</span>
        } else {
<span class="fc" id="L182">            from = p2;</span>
<span class="fc" id="L183">            to = p1;</span>
        }

        // Calculate mid point of 2 latitudes.
<span class="fc" id="L187">        final double avgLat = (from.getLatDeg() + to.getLatDeg()) / 2.0;</span>

<span class="fc" id="L189">        final double deltaLatDeg = Math.abs(to.getLatDeg() - from.getLatDeg());</span>
<span class="fc" id="L190">        final double deltaLonDeg360 = Math.abs(to.getLonDeg() - from.getLonDeg());</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        final double deltaLonDeg = ((deltaLonDeg360 &lt;= 180.0) ? deltaLonDeg360 : (360.0 - deltaLonDeg360));</span>

        // Meters per longitude is fixed; per latitude requires * cos(avg(lat)).
<span class="fc" id="L194">        final double deltaXMeters = degreesLonToMetersAtLat(deltaLonDeg, avgLat);</span>
<span class="fc" id="L195">        final double deltaYMeters = degreesLatToMeters(deltaLatDeg);</span>


        // Calculate length through Earth. This is an approximation, but works fine for short distances.
<span class="fc" id="L199">        return Math.sqrt((deltaXMeters * deltaXMeters) + (deltaYMeters * deltaYMeters));</span>
    }

    public static double degreesLatToMeters(final double latDegrees) {
<span class="fc" id="L203">        return latDegrees * METERS_PER_DEGREE_LAT;</span>
    }

    public static double degreesLonToMetersAtLat(final double lonDegrees, final double lat) {
<span class="fc" id="L207">        return lonDegrees * METERS_PER_DEGREE_LON_EQUATOR * Math.cos(Math.toRadians(lat));</span>
    }

    public static double metersToDegreesLonAtLat(final double eastMeters, final double lat) {
<span class="fc" id="L211">        return (eastMeters / METERS_PER_DEGREE_LON_EQUATOR) / Math.cos(Math.toRadians(lat));</span>
    }

    @Nonnull
    @Override
    public String toString() {
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        return defined ? (&quot;(&quot; + getLatDeg() + &quot;, &quot; + getLonDeg() + ')') : &quot;undefined&quot;;</span>
    }

    @SuppressWarnings(&quot;NonFinalFieldReferencedInHashCode&quot;)
    @Override
    public int hashCode() {
<span class="nc" id="L223">        return Arrays.hashCode(new Object[]{getLatDeg(), getLonDeg(), defined});</span>
    }

    @SuppressWarnings(&quot;NonFinalFieldReferenceInEquals&quot;)
    @Override
    public boolean equals(final Object o) {
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (this == o) {</span>
<span class="nc" id="L230">            return true;</span>
        }
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (!(o instanceof Point)) {</span>
<span class="nc" id="L233">            return false;</span>
        }
<span class="fc" id="L235">        final Point that = (Point) o;</span>
<span class="pc bpc" id="L236" title="5 of 10 branches missed.">        return (this.latMicroDeg == that.latMicroDeg) &amp;&amp;</span>
                (this.lonMicroDeg == that.lonMicroDeg) &amp;&amp;
                (this.latFractionOnlyDeg == that.latFractionOnlyDeg) &amp;&amp;
                (this.lonFractionOnlyDeg == that.lonFractionOnlyDeg) &amp;&amp;
                (this.defined == that.defined);
    }

    /**
     * -----------------------------------------------------------------------
     * (Package) private data and methods.
     * -----------------------------------------------------------------------
     */
    // Constants to convert between Degrees, MicroDegrees and Fractions
    static final double MICRODEG_TO_DEG_FACTOR = 1000000.0;
    static final double MAX_PRECISION_FACTOR = 810000.0;
    static final double LAT_MICRODEG_TO_FRACTIONS_FACTOR = MAX_PRECISION_FACTOR;
    static final double LON_MICRODEG_TO_FRACTIONS_FACTOR = MAX_PRECISION_FACTOR * 4;
    static final double LAT_TO_FRACTIONS_FACTOR = MICRODEG_TO_DEG_FACTOR * LAT_MICRODEG_TO_FRACTIONS_FACTOR;
    static final double LON_TO_FRACTIONS_FACTOR = MICRODEG_TO_DEG_FACTOR * LON_MICRODEG_TO_FRACTIONS_FACTOR;

    private int latMicroDeg;            // Whole nr of MICRODEG_TO_DEG_FACTOR.
    private int lonMicroDeg;            // Whole nr of MICRODEG_TO_DEG_FACTOR.
    private int latFractionOnlyDeg;     // Whole nr of LAT_TO_FRACTIONS_FACTOR, relative to latMicroDeg.
    private int lonFractionOnlyDeg;     // Whole nr of LON_TO_FRACTIONS_FACTOR, relative to lonMicroDeg.

    /**
     * Points can be &quot;undefined&quot; within the mapcode implementation, but never outside of that.
     * Any methods creating or setting undefined points must be package private and external
     * interfaces must never pass undefined points to callers.
     */
    private boolean defined;

    /**
     * Private constructors.
     */
<span class="fc" id="L271">    private Point() {</span>
<span class="fc" id="L272">        defined = false;</span>
<span class="fc" id="L273">    }</span>

    /**
     * Public construction, from floating point degrees (potentially lossy).
     */
    @SuppressWarnings(&quot;NumericCastThatLosesPrecision&quot;)
<span class="fc" id="L279">    private Point(final double latDeg, final double lonDeg) {</span>

<span class="fc" id="L281">        double lat = latDeg + 90;</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (lat &lt; 0) {</span>
<span class="fc" id="L283">            lat = 0;</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">        } else if (lat &gt; 180) {</span>
<span class="fc" id="L285">            lat = 180;</span>
        }

        // Rounding factor.
<span class="fc" id="L289">        final double fractionRounding = 0.1;</span>

        // Lat now [0..180].
<span class="fc" id="L292">        lat = lat * LAT_TO_FRACTIONS_FACTOR;</span>
<span class="fc" id="L293">        double latFractionOnly = Math.floor(lat + fractionRounding);</span>
<span class="fc" id="L294">        latMicroDeg = (int) (latFractionOnly / LAT_MICRODEG_TO_FRACTIONS_FACTOR);</span>
<span class="fc" id="L295">        latFractionOnly = latFractionOnly - ((double) latMicroDeg * LAT_MICRODEG_TO_FRACTIONS_FACTOR);</span>
<span class="fc" id="L296">        latFractionOnlyDeg = (int) latFractionOnly;</span>
<span class="fc" id="L297">        latMicroDeg = latMicroDeg - MICRO_DEG_90;</span>

        // Math.floor has limited precision for really large values, so we need to limit the lon explicitly.
<span class="fc" id="L300">        double lon = Math.min(360.0, Math.max(0.0, lonDeg - (360.0 * Math.floor(lonDeg / 360.0))));</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (Double.compare(lon, 360.0) == 0) {</span>
<span class="fc" id="L302">            lon = 0.0;</span>
        }

        // Lon now in [0..360&gt;.
<span class="fc" id="L306">        lon = lon * LON_TO_FRACTIONS_FACTOR;</span>
<span class="fc" id="L307">        double lonFractionOnly = Math.floor(lon + fractionRounding);</span>
<span class="fc" id="L308">        lonMicroDeg = (int) (lonFractionOnly / LON_MICRODEG_TO_FRACTIONS_FACTOR);</span>
<span class="fc" id="L309">        lonFractionOnly = lonFractionOnly - ((double) lonMicroDeg * LON_MICRODEG_TO_FRACTIONS_FACTOR);</span>
<span class="fc" id="L310">        lonFractionOnlyDeg = (int) lonFractionOnly;</span>

        // Wrap lonMicroDeg from [0..360&gt; to [-180..180).
<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (lonMicroDeg &gt;= MICRO_DEG_180) {</span>
<span class="fc" id="L314">            lonMicroDeg = lonMicroDeg - MICRO_DEG_360;</span>
        }

<span class="fc" id="L317">        defined = true;</span>
<span class="fc" id="L318">    }</span>

    /**
     * Get the the longitude &quot;fractions&quot;, which is a whole number of 1/LON_TO_FRACTIONS_FACTOR-th
     * degrees versus the millionths of degrees.
     */
    int getLonFraction() {
<span class="pc bpc" id="L325" title="2 of 4 branches missed.">        assert defined;</span>
<span class="fc" id="L326">        return lonFractionOnlyDeg;</span>
    }

    /**
     * Get the the latitude &quot;fractions&quot;, which is a whole number of 1/LAT_TO_FRACTIONS_FACTOR-th
     * degrees versus the millionths of degrees
     */
    int getLatFraction() {
<span class="pc bpc" id="L334" title="2 of 4 branches missed.">        assert defined;</span>
<span class="fc" id="L335">        return latFractionOnlyDeg;</span>
    }

    /**
     * Package private construction, from integer fractions (no loss of precision).
     */
    @SuppressWarnings(&quot;NumericCastThatLosesPrecision&quot;)
    @Nonnull
    static Point fromLatLonFractions(final double latFraction, final double lonFraction) {
<span class="fc" id="L344">        final Point p = new Point();</span>
<span class="fc" id="L345">        p.latMicroDeg = (int) Math.floor(latFraction / LAT_MICRODEG_TO_FRACTIONS_FACTOR);</span>
<span class="fc" id="L346">        p.latFractionOnlyDeg = (int) (latFraction - (LAT_MICRODEG_TO_FRACTIONS_FACTOR * p.latMicroDeg));</span>
<span class="fc" id="L347">        p.lonMicroDeg = (int) Math.floor(lonFraction / LON_MICRODEG_TO_FRACTIONS_FACTOR);</span>
<span class="fc" id="L348">        p.lonFractionOnlyDeg = (int) (lonFraction - (LON_MICRODEG_TO_FRACTIONS_FACTOR * p.lonMicroDeg));</span>
<span class="fc" id="L349">        p.defined = true;</span>
<span class="fc" id="L350">        return p.wrap();</span>
    }

    static int degToMicroDeg(final double deg) {
        //noinspection NumericCastThatLosesPrecision
<span class="nc" id="L355">        return (int) Math.floor(deg * MICRODEG_TO_DEG_FACTOR);</span>
    }

    static double microDegToDeg(final int microDeg) {
<span class="nc" id="L359">        return ((double) microDeg) / MICRODEG_TO_DEG_FACTOR;</span>
    }

    @Nonnull
    Point wrap() {
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (defined) {</span>
            // Cut latitude to [-90, 90].
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">            if (latMicroDeg &lt; -MICRO_DEG_90) {</span>
<span class="nc" id="L367">                latMicroDeg = -MICRO_DEG_90;</span>
<span class="nc" id="L368">                latFractionOnlyDeg = 0;</span>
            }
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">            if (latMicroDeg &gt; MICRO_DEG_90) {</span>
<span class="nc" id="L371">                latMicroDeg = MICRO_DEG_90;</span>
<span class="nc" id="L372">                latFractionOnlyDeg = 0;</span>
            }
            // Map longitude to [-180, 180). Values outside this range are wrapped to this range.
<span class="fc" id="L375">            lonMicroDeg %= MICRO_DEG_360;</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">            if (lonMicroDeg &gt;= MICRO_DEG_180) {</span>
<span class="fc" id="L377">                lonMicroDeg -= MICRO_DEG_360;</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            } else if (lonMicroDeg &lt; -MICRO_DEG_180) {</span>
<span class="fc" id="L379">                lonMicroDeg += MICRO_DEG_360;</span>
            }
        }
<span class="fc" id="L382">        return this;</span>
    }

    /**
     * Create an undefined points. No latitude or longitude can be obtained from it.
     * Only within the mapcode implementation points can be undefined, so this methods is package private.
     *
     * @return Undefined points.
     */
    @Nonnull
    static Point undefined() {
<span class="fc" id="L393">        return new Point();</span>
    }

    /**
     * Set a point to be undefined, invalidating the latitude and longitude.
     * Only within the mapcode implementation points can be undefined, so this methods is package private.
     */
    void setUndefined() {
<span class="fc" id="L401">        defined = false;</span>
<span class="fc" id="L402">    }</span>

    /**
     * Return whether the point is defined or not.
     * Only within the mapcode implementation points can be undefined, so this methods is package private.
     *
     * @return True if defined. If false, no lat/lon is available.
     */
    boolean isDefined() {
<span class="fc" id="L411">        return defined;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>