<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Mapcode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Mapcode Java Library</a> &gt; <a href="index.source.html" class="el_package">com.mapcode</a> &gt; <span class="el_source">Mapcode.java</span></div><h1>Mapcode.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2014-2016 Stichting Mapcode Foundation (http://www.mapcode.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.mapcode;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.mapcode.CheckArgs.checkMapcodeCode;
import static com.mapcode.CheckArgs.checkNonnull;

/**
 * This class defines a single mapcode encoding result, including the alphanumeric code and the
 * territory definition.
 *
 * On terminology, mapcode territory and mapcode code:
 *
 * In written form. a mapcode is defined as an alphanumeric code, optionally preceded by a
 * territory code.
 *
 * For example: &quot;NLD 49.4V&quot; is a mapcode, but &quot;49.4V&quot; is a mapcode as well, The latter is called
 * a &quot;local&quot; mapcode, because it is not internationally unambiguous unless preceded by a territory
 * code.
 *
 * For &quot;NLD 49.4V&quot; the &quot;NLD&quot;-part is called &quot;the territory&quot; and the &quot;49.4V&quot;-part is called
 * &quot;the code&quot; (which are both part of &quot;the mapcode&quot;).
 *
 * This distinction between &quot;territory&quot; and &quot;code&quot; in a mapcode is why the interface of this class
 * has been changed from version 1.50.0 to reflect this terminology.
 *
 * On alphabets:
 *
 * Mapcode codes can be represented in different alphabets. Note that an alphabet is something else
 * than a locale or a language. The supported alphabets for mapcodes are listed in {@link Alphabet}.
 *
 * Mapcode objects provide methods to obtain the mapcode code in a specific alphabet. By default,
 * the {@link Alphabet#ROMAN} is used.
 */
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">public final class Mapcode {</span>

    @Nonnull
    private final Territory territory;

    @Nonnull
    private final String codePrecision8;    // Internally, codes are always stored at precision 8.

    /**
     * Create a mapcode object. Normally, mapcodes are created be encoding a lat/lon pair
     * using {@link MapcodeCodec#encode(double, double)} rather than creating them yourself.
     *
     * Note that it is possible to create invalid mapcodes this way, which are syntactically
     * correct.
     *
     * Note that the constructor will throw an {@link IllegalArgumentException} if the syntax of the mapcode
     * is not correct. The mapcode is not checked for validity, other than its syntax.
     *
     * @param code      Code of mapcode.
     * @param territory Territory.
     * @throws IllegalArgumentException Thrown if syntax not valid or if the mapcode string contains
     *                                  territory information.
     */
    public Mapcode(
        @Nonnull final String code,
<span class="fc" id="L80">        @Nonnull final Territory territory) throws IllegalArgumentException {</span>

<span class="fc" id="L82">        checkMapcodeCode(&quot;code&quot;, code);</span>
<span class="fc" id="L83">        final String ascii = convertStringToPlainAscii(code);</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        if (containsTerritory(ascii)) {</span>
<span class="nc" id="L85">            throw new IllegalArgumentException(&quot;Must not contain territory: &quot; + code);</span>
        }

        // Build codeUppercase with exactly eight precision digits.
<span class="fc" id="L89">        String codeUppercase = ascii.toUpperCase();</span>
<span class="fc" id="L90">        final int hyphenPos = codeUppercase.indexOf('-');</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (hyphenPos &lt; 0) {</span>
<span class="nc" id="L92">            codeUppercase = codeUppercase + &quot;-K3000000&quot;;</span>
        }
        else {
<span class="fc" id="L95">            final int extensionLength = codeUppercase.length() - 1 - hyphenPos;</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">            if (extensionLength &lt; 8) {</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">                if ((extensionLength % 2) == 1) {</span>
                    // Odd extension.
<span class="nc" id="L99">                    codeUppercase = codeUppercase + (&quot;HH000000&quot;.substring(0, 8 - extensionLength));</span>
                }
                else {
                    // Even extension.
<span class="nc" id="L103">                    codeUppercase = codeUppercase + (&quot;K3000000&quot;.substring(0, 8 - extensionLength));</span>
                }
            }
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            else if (extensionLength &gt; 8) {</span>
                // Cut to 8 characters.
<span class="nc" id="L108">                codeUppercase = codeUppercase.substring(0, hyphenPos + 9);</span>
            }
        }

<span class="fc" id="L112">        this.codePrecision8 = codeUppercase;</span>
<span class="fc" id="L113">        this.territory = territory;</span>
<span class="fc" id="L114">    }</span>

    /**
     * Get the Mapcode string (without territory information) with standard precision.
     * The returned mapcode does not include the '-' separator and additional digits.
     *
     * A mapcode defines an area of approximately 10 x 10 meters (100 m2) and will decode
     * to the center of that area. On average, the original coordinate will be 3.6 meters
     * from this center: the average inaccuracy of a mapcode.
     *
     * @param alphabet Alphabet.
     * @return Mapcode string.
     */
    @Nonnull
    public String getCode(@Nullable final Alphabet alphabet) {
<span class="fc" id="L129">        return getCode(0, alphabet);</span>
    }

    @Nonnull
    public String getCode() {
<span class="fc" id="L134">        return getCode(0, null);</span>
    }

    /**
     * Get the mapcode code (without territory information) with a specified precision.
     * The returned mapcode includes a '-' separator and additional digits for precisions 1 to 8.
     *
     * The precision defines the size of a geographical area a single mapcode covers. This means It also defines
     * the maximum distance to the location, a (latitude, longitude) pair, that encoded to this mapcode.
     *
     * Precision 0: area is approx 10 x 10 meters (100 m2); max. distance from original location less than 7.5 meters.
     * Precision 1: area is approx 3.33 m2; max. distance from original location less than 1.5 meters.
     * Precision 1: area is approx 0.11 m2; max. distance from original location less than 0.4 meters.
     * etc. (each level reduces the area by a factor of 30)
     *
     * The accuracy is slightly better than the figures above, but these figures are safe assumptions.
     *
     * @param precision Precision. Range: 0..8.
     * @param alphabet  Alphabet.
     * @return Mapcode code.
     * @throws IllegalArgumentException Thrown if precision is out of range (must be in [0, 8]).
     */
    @Nonnull
    public String getCode(final int precision, @Nullable final Alphabet alphabet) {
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (precision == 0) {</span>
<span class="fc" id="L159">            return convertStringToAlphabet(codePrecision8.substring(0, codePrecision8.length() - 9), alphabet);</span>
        }
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        else if (precision &lt;= 8) {</span>
<span class="fc" id="L162">            return convertStringToAlphabet(codePrecision8.substring(0, (codePrecision8.length() - 8) + precision),</span>
                alphabet);
        }
        else {
<span class="nc" id="L166">            throw new IllegalArgumentException(&quot;getCodePrecision: precision must be in [0, 8]&quot;);</span>
        }
    }

    @Nonnull
    public String getCode(final int precision) throws IllegalArgumentException {
<span class="fc" id="L172">        return getCode(precision, null);</span>
    }

    /**
     * Return the full international mapcode, including the full name of the territory and the mapcode code itself.
     * The format of the string is:
     * full-territory-name cde
     *
     * Example:
     * Netherlands 49.4V           (regular code)
     * Netherlands 49.4V-K2        (high precision code)
     *
     * @param precision Precision specifier. Range: [0, 8].
     * @param alphabet  Alphabet.
     * @return Full international mapcode.
     * @throws IllegalArgumentException Thrown if precision is out of range (must be in [0, 8]).
     */
    @Nonnull
    public String getCodeWithTerritoryFullname(final int precision, @Nullable final Alphabet alphabet) throws IllegalArgumentException {
<span class="nc" id="L191">        return territory.getFullName() + ' ' + getCode(precision, alphabet);</span>
    }

    @Nonnull
    public String getCodeWithTerritoryFullname(final int precision) throws IllegalArgumentException {
<span class="nc" id="L196">        return getCodeWithTerritoryFullname(precision, null);</span>
    }

    @Nonnull
    public String getCodeWithTerritoryFullname(@Nullable final Alphabet alphabet) {
<span class="nc" id="L201">        return getCodeWithTerritoryFullname(0, alphabet);</span>
    }

    @Nonnull
    public String getCodeWithTerritoryFullname() {
<span class="nc" id="L206">        return getCodeWithTerritoryFullname(0, null);</span>
    }

    /**
     * Return the international mapcode as a shorter version using the ISO territory codes where possible.
     * International codes use a territory code &quot;AAA&quot;.
     * The format of the code is:
     * short-territory-name mapcode
     *
     * Example:
     * NLD 49.4V                   (regular code)
     * NLD 49.4V-K2                (high-precision code)
     *
     * @param precision Precision specifier. Range: [0, 8].
     * @param alphabet  Alphabet.
     * @return Short-hand international mapcode.
     * @throws IllegalArgumentException Thrown if precision is out of range (must be in [0, 8]).
     */
    @Nonnull
    public String getCodeWithTerritory(final int precision, @Nullable final Alphabet alphabet) throws IllegalArgumentException {
<span class="fc" id="L226">        return territory.toString() + ' ' + getCode(precision, alphabet);</span>
    }

    @Nonnull
    public String getCodeWithTerritory(final int precision) throws IllegalArgumentException {
<span class="fc" id="L231">        return getCodeWithTerritory(precision, null);</span>
    }

    @Nonnull
    public String getCodeWithTerritory(@Nonnull final Alphabet alphabet) {
<span class="nc" id="L236">        return getCodeWithTerritory(0, alphabet);</span>
    }

    @Nonnull
    public String getCodeWithTerritory() {
<span class="fc" id="L241">        return getCodeWithTerritory(0, null);</span>
    }

    /**
     * Get the territory information.
     *
     * @return Territory information.
     */
    @Nonnull
    public Territory getTerritory() {
<span class="fc" id="L251">        return territory;</span>
    }

    /**
     * These patterns and matchers are used internally in this module to match mapcodes. They are
     * provided as statics to only compile these patterns once.
     */
    @Nonnull
    static final String REGEX_TERRITORY      = &quot;[\\p{L}\\p{N}]{2,3}+([-_][\\p{L}\\p{N}]{2,3}+)?&quot;;
    @Nonnull
    static final String REGEX_CODE_PREFIX    = &quot;[\\p{L}\\p{N}]{2,5}+&quot;;
    @Nonnull
    static final String REGEX_CODE_POSTFIX   = &quot;[\\p{L}\\p{N}]{2,4}+&quot;;
    @Nonnull
    static final String REGEX_CODE_PRECISION = &quot;[-][\\p{L}\\p{N}&amp;&amp;[^zZ]]{1,8}+&quot;;

    /**
     * This patterns/regular expressions is used for checking mapcode format strings.
     * They've been made public to allow others to use the correct regular expressions as well.
     */
    @Nonnull
    public static final String REGEX_MAPCODE = '(' + REGEX_TERRITORY + &quot;[ ]+)?&quot; +
        REGEX_CODE_PREFIX + &quot;[.]&quot; + REGEX_CODE_POSTFIX + '(' + REGEX_CODE_PRECISION + &quot;)?&quot;;

    @Nonnull
<span class="fc" id="L276">    static final Pattern PATTERN_MAPCODE   = Pattern.compile('^' + REGEX_MAPCODE + '$');</span>
    @Nonnull
<span class="fc" id="L278">    static final Pattern PATTERN_TERRITORY = Pattern.compile('^' + REGEX_TERRITORY + ' ');</span>
    @Nonnull
<span class="fc" id="L280">    static final Pattern PATTERN_PRECISION = Pattern.compile(REGEX_CODE_PRECISION + '$');</span>

    /**
     * This method return the mapcode type, given a mapcode string. If the mapcode string has an invalid
     * format, an exception is thrown.
     *
     * Note that this method only checks the syntactic validity of the mapcode, the string format. It does not
     * check if the mapcode is really a valid mapcode representing a position on Earth.
     *
     * @param mapcode Mapcode (optionally with a territory).
     * @return Type of mapcode code format.
     * @throws UnknownPrecisionFormatException If precision format is incorrect.
     */
    public static int getPrecisionFormat(@Nonnull final String mapcode) throws UnknownPrecisionFormatException {

        // First, decode to ASCII.
<span class="fc" id="L296">        final String decodedMapcode = convertStringToPlainAscii(mapcode).toUpperCase();</span>

        // Syntax needs to be OK.
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (!PATTERN_MAPCODE.matcher(decodedMapcode).matches()) {</span>
<span class="fc" id="L300">            throw new UnknownPrecisionFormatException(decodedMapcode + &quot; is not a correctly formatted mapcode code; &quot; +</span>
                &quot;the regular expression for the mapcode code syntax is: &quot; + REGEX_MAPCODE);
        }

        // Precision part should be OK.
<span class="fc" id="L305">        final Matcher matcherPrecision = PATTERN_PRECISION.matcher(decodedMapcode);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (!matcherPrecision.find()) {</span>
<span class="fc" id="L307">            return 0;</span>
        }
<span class="fc" id="L309">        final int length = matcherPrecision.end() - matcherPrecision.start() - 1;</span>
<span class="pc bpc" id="L310" title="3 of 6 branches missed.">        assert (1 &lt;= length) &amp;&amp; (length &lt;= 8);</span>
<span class="fc" id="L311">        return length;</span>
    }

    /**
     * This method provides a shortcut to checking if a mapcode string is formatted properly or not at all.
     *
     * @param mapcode Mapcode (optionally with a territory).
     * @return True if the mapcode format, the syntax, is correct. This does not mean the mapcode code is
     * actually a valid  mapcode representing a location on Earth.
     * @throws IllegalArgumentException If mapcode is null.
     */
    public static boolean isValidMapcodeFormat(@Nonnull final String mapcode) throws IllegalArgumentException {
<span class="fc" id="L323">        checkNonnull(&quot;mapcode&quot;, mapcode);</span>
        try {
            // Throws an exception if the format is incorrect.
<span class="fc" id="L326">            getPrecisionFormat(mapcode.toUpperCase());</span>
<span class="fc" id="L327">            return true;</span>
        }
<span class="fc" id="L329">        catch (final UnknownPrecisionFormatException ignored) {</span>
<span class="fc" id="L330">            return false;</span>
        }
    }

    /**
     * Returns whether the mapcode contains territory information or not.
     *
     * @param mapcode Mapcode string, optionally with territory information.
     * @return True if mapcode contains territory information.
     * @throws IllegalArgumentException If mapcode has incorrect syntax.
     */
    public static boolean containsTerritory(@Nonnull final String mapcode) throws IllegalArgumentException {
<span class="fc" id="L342">        checkMapcodeCode(&quot;mapcode&quot;, mapcode);</span>
<span class="fc" id="L343">        return PATTERN_TERRITORY.matcher(mapcode.toUpperCase().trim()).find();</span>
    }

    /**
     * This array defines the safe maximum offset between a decoded mapcode and its original
     * location used for encoding the mapcode.
     */
<span class="fc" id="L350">    private static final double[] PRECISION_0_MAX_OFFSET_METERS = {</span>
        7.49,         // PRECISION_0: 7.49 meters or less       +/- 7.5 m
        1.39,         // PRECISION_1: 1.39 meters or less       +/- 1.4 m
        0.251,        // PRECISION_2: 25.1 cm or less           +/- 25 cm
        0.0462,       // PRECISION_3: 4.62 cm or less           +/- 5 cm
        0.00837,      // PRECISION_4: 8.37 mm or less           +/- 1 cm
        0.00154,      // PRECISION_5: 1.54 mm or less           +/- 2 mm
        0.000279,     // PRECISION_6: 279 micrometer or less    +/- 1/3 mm
        0.0000514,    // PRECISION_7: 51.4 micrometer or less   +/- 1/20 mm
        0.0000093     // PRECISION_8: 9.3 micrometer or less    +/- 1/100 mm
    };

    /**
     * Get a safe maximum for the distance between a decoded mapcode and its original
     * location used for encoding the mapcode. The actual accuracy (resolution) of mapcodes is
     * better than this, but these are safe values to use under normal circumstances.
     *
     * Do not make any other assumptions on these numbers than that mapcodes are never more off
     * by this distance.
     *
     * @param precision Precision of mapcode.
     * @return Maximum offset in meters.
     */
    public static double getSafeMaxOffsetInMeters(final int precision) {
<span class="pc bpc" id="L374" title="2 of 4 branches missed.">        if ((precision &lt; 0) || (precision &gt; 8)) {</span>
<span class="nc" id="L375">            throw new IllegalArgumentException(&quot;precision must be in [0, 8]&quot;);</span>
        }
<span class="fc" id="L377">        return PRECISION_0_MAX_OFFSET_METERS[precision];</span>
    }

    /**
     * Convert a string which potentially contains Unicode characters, to an ASCII variant.
     *
     * @param string Any string.
     * @return ASCII, non-Unicode string.
     */
    @Nonnull
    static String convertStringToPlainAscii(@Nonnull final String string) {
<span class="fc" id="L388">        return Decoder.decodeUTF16(string.toUpperCase());</span>
    }

    /**
     * Convert a string into the same string using a different (or the same) alphabet.
     *
     * @param string   Any string.
     * @param alphabet Alphabet to convert to, may contain Unicode characters.
     * @return Converted mapcode.
     * @throws IllegalArgumentException Thrown if string has incorrect syntax or if the string cannot be encoded in
     *                                  the specified alphabet.
     */
    @Nonnull
    static String convertStringToAlphabet(@Nonnull final String string, @Nullable final Alphabet alphabet) throws IllegalArgumentException {
<span class="fc bfc" id="L402" title="All 2 branches covered.">        return (alphabet != null) ? Decoder.encodeUTF16(string.toUpperCase(), alphabet.getNumber()) :</span>
<span class="fc" id="L403">            string.toUpperCase();</span>
    }

    /**
     * This method is defined as returning the mapcode code including its territory,
     * with normal precision (precision 0).
     *
     * @return Mapcode, including territory and code. Plain ASCII, non-Unicode.
     */
    @Nonnull
    @Override
    public String toString() {
<span class="fc" id="L415">        return getCodeWithTerritory();</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L420">        return Arrays.deepHashCode(new Object[]{codePrecision8, territory});</span>
    }

    @Override
    public boolean equals(@Nullable final Object obj) {
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L426">            return true;</span>
        }
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        if (!(obj instanceof Mapcode)) {</span>
<span class="nc" id="L429">            return false;</span>
        }
<span class="fc" id="L431">        final Mapcode that = (Mapcode) obj;</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">        return this.territory.equals(that.territory) &amp;&amp;</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">            this.codePrecision8.equals(that.codePrecision8);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>