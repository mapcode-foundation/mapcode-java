<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Mapcode Java Library</a> &gt; <a href="index.source.html" class="el_package">com.mapcode</a> &gt; <span class="el_source">DataModel.java</span></div><h1>DataModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2014-2017, Stichting Mapcode Foundation (http://www.mapcode.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.mapcode;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

// ----------------------------------------------------------------------------------------------
// Package private implementation class. For internal use within the Mapcode implementation only.
// ----------------------------------------------------------------------------------------------

/**
 * This class contains the module that reads the Mapcode areas into memory and processes them.
 */
<span class="pc bpc" id="L34" title="1 of 2 branches missed.">@SuppressWarnings(&quot;MagicNumber&quot;)</span>
class DataModel {
<span class="fc" id="L36">    private static final Logger LOG = LoggerFactory.getLogger(DataModel.class);</span>

    // TODO: This class needs a thorough description of what the data file format looks like and what all bit fields means exactly.
    private static final int HEADER_ID_1 = 0;
    private static final int HEADER_ID_2 = 1;
    private static final int HEADER_VERSION_LO = 2;
    private static final int HEADER_VERSION_HI = 3;
    private static final int HEADER_NR_TERRITORIES_RECS_LO = 4;
    private static final int HEADER_NR_TERRITORIES_RECS_HI = 5;
    private static final int HEADER_NR_TERRITORIES_LO = 6;
    private static final int HEADER_NR_TERRITORIES_HI = 7;
    private static final int HEADER_SIZE = HEADER_NR_TERRITORIES_HI + 1;

    private static final int BYTES_PER_INT = 2;
    private static final int BYTES_PER_LONG = 4;

    private static final int POS_DATA_LON_MICRO_DEG_MIN = 0;
    private static final int POS_DATA_LAT_MICRO_DEG_MIN = 1;
    private static final int POS_DATA_LON_MICRO_DEG_MAX = 2;
    private static final int POS_DATA_LAT_MICRO_DEG_MAX = 3;
    private static final int POS_DATA_DATA_FLAGS = 4;
    private static final int DATA_FIELDS_PER_REC = 5;

    private static final int MASK_DATA_DATA_FLAGS = 0xffff;
    private static final int SHIFT_POS_DATA_SMART_DIV = 16;

    private static final int POS_INDEX_FIRST_RECORD = 0;
    private static final int POS_INDEX_LAST_RECORD = 1;

    private static final String DATA_FILE_NAME = &quot;/com/mapcode/mminfo.dat&quot;;
    private static final int FILE_BUFFER_SIZE = 50000;

    private static final int DATA_VERSION_MIN = 220;

    private static int readIntLoHi(final int lo, final int hi) {
<span class="fc" id="L71">        return (lo &amp; 0xff) + ((hi &amp; 0xff) &lt;&lt; 8);</span>
    }

    private static int readLongLoHi(final int lo, final int mid1, final int mid2, final int hi) {
<span class="fc" id="L75">        return ((lo &amp; 0xff)) + ((mid1 &amp; 0xff) &lt;&lt; 8) + ((mid2 &amp; 0xff) &lt;&lt; 16) + ((hi &amp; 0xff) &lt;&lt; 24);</span>
    }

    // Data.
    private final int nrTerritories;
    private final int nrTerritoryRecords;

    private final int[] index;
    private final int[] data;

<span class="fc" id="L85">    private static volatile DataModel instance = null;</span>
<span class="fc" id="L86">    private static final Object mutex = new Object();</span>

    @SuppressWarnings({&quot;DoubleCheckedLocking&quot;, &quot;SynchronizationOnStaticField&quot;})
    public static DataModel getInstance() {
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if (instance == null) {</span>
<span class="fc" id="L91">            synchronized (mutex) {</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">                if (instance == null) {</span>
<span class="fc" id="L93">                    instance = new DataModel(DATA_FILE_NAME);</span>
                }
<span class="fc" id="L95">            }</span>
        }
<span class="fc" id="L97">        return instance;</span>
    }

    @SuppressWarnings(&quot;NestedTryStatement&quot;)
<span class="fc" id="L101">    DataModel(@Nonnull final String fileName) throws IncorrectDataModelException {</span>
        // Read data only once in static initializer.
<span class="fc" id="L103">        LOG.info(&quot;DataModel: reading regions from file: {}&quot;, fileName);</span>
<span class="fc" id="L104">        final byte[] readBuffer = new byte[FILE_BUFFER_SIZE];</span>
<span class="fc" id="L105">        int total = 0;</span>
        try {
<span class="fc" id="L107">            final InputStream inputStream = DataModel.class.getResourceAsStream(fileName);</span>
            try {
<span class="fc" id="L109">                final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</span>
                try {

                    // Read the input stream, copy to memory buffer.
<span class="fc" id="L113">                    int nrBytes = inputStream.read(readBuffer);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">                    while (nrBytes &gt; 0) {</span>
<span class="fc" id="L115">                        total += nrBytes;</span>
<span class="fc" id="L116">                        outputStream.write(readBuffer, 0, nrBytes);</span>
<span class="fc" id="L117">                        nrBytes = inputStream.read(readBuffer);</span>
                    }

                    // Copy stream into data.
<span class="fc" id="L121">                    final byte[] bytes = outputStream.toByteArray();</span>
<span class="pc bpc" id="L122" title="2 of 4 branches missed.">                    assert total == bytes.length;</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">                    if (total &lt; 12) {</span>
<span class="fc" id="L124">                        LOG.error(&quot;DataModel: expected more than {} bytes&quot;, total);</span>
<span class="fc" id="L125">                        throw new IncorrectDataModelException(&quot;Data file corrupt: &quot; + fileName);</span>
                    }

                    // Read &quot;MC&quot;, VERSION.
<span class="pc bpc" id="L129" title="2 of 4 branches missed.">                    assert total &gt; 8;  // &quot;MC&quot; (2) + VERSION (2) + NR TERRITORIES (2) + NR TERRITORY RECORDS (2).</span>
<span class="pc bpc" id="L130" title="1 of 4 branches missed.">                    if ((bytes[HEADER_ID_1] != 'M') || (bytes[HEADER_ID_2] != 'C')) {</span>
<span class="fc" id="L131">                        throw new IncorrectDataModelException(&quot;Data file does not start with correct header: &quot; + fileName);</span>
                    }
<span class="fc" id="L133">                    final int dataVersion = readIntLoHi(bytes[HEADER_VERSION_LO], bytes[HEADER_VERSION_HI]);</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">                    if (dataVersion &lt; DATA_VERSION_MIN) {</span>
<span class="fc" id="L136">                        throw new IncorrectDataModelException(&quot;Data file version &quot; + dataVersion + &quot; too low: &quot; + fileName);</span>
                    }

                    // Read header: NR TERRITORIES, NR RECTANGLE RECORDS.
<span class="fc" id="L140">                    nrTerritoryRecords = readIntLoHi(bytes[HEADER_NR_TERRITORIES_RECS_LO], bytes[HEADER_NR_TERRITORIES_RECS_HI]);</span>
<span class="fc" id="L141">                    nrTerritories = readIntLoHi(bytes[HEADER_NR_TERRITORIES_LO], bytes[HEADER_NR_TERRITORIES_HI]);</span>

                    // Check if the number of territories matches the enumeration in Territory.
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">                    if (nrTerritories != Territory.values().length) {</span>
<span class="nc" id="L145">                        LOG.error(&quot;DataModel: expected {} territories, got {}&quot;, Territory.values().length, nrTerritories);</span>
<span class="nc" id="L146">                        throw new IncorrectDataModelException(&quot;Data file corrupt: &quot; + fileName);</span>
                    }

                    // Check if the expected file size matched what we found.
<span class="fc" id="L150">                    final int expectedSize = HEADER_SIZE +</span>
                            ((nrTerritories + 1) * BYTES_PER_INT) +
                            (nrTerritoryRecords * (DATA_FIELDS_PER_REC * BYTES_PER_LONG));

<span class="fc bfc" id="L154" title="All 2 branches covered.">                    if (expectedSize != total) {</span>
<span class="fc" id="L155">                        LOG.error(&quot;DataModel: expected {} bytes, got {}&quot;, expectedSize, total);</span>
<span class="fc" id="L156">                        throw new IncorrectDataModelException(&quot;Data file corrupt: &quot; + fileName);</span>
                    }
<span class="fc" id="L158">                    LOG.debug(&quot;DataModel: version={} territories={} territory records={}&quot;, dataVersion, nrTerritories, nrTerritoryRecords);</span>

                    // Read DATA+START array (2 bytes per territory, plus closing record).
<span class="fc" id="L161">                    index = new int[nrTerritories + 1];</span>
<span class="fc" id="L162">                    int i = HEADER_SIZE;</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                    for (int k = 0; k &lt;= nrTerritories; k++) {</span>
<span class="fc" id="L164">                        index[k] = readIntLoHi(bytes[i], bytes[i + 1]);</span>
<span class="fc" id="L165">                        i += 2;</span>
                    }

                    // Read territory rectangle data (DATA_FIELDS_PER_REC longs per record).
<span class="fc" id="L169">                    data = new int[nrTerritoryRecords * DATA_FIELDS_PER_REC];</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">                    for (int k = 0; k &lt; (nrTerritoryRecords * DATA_FIELDS_PER_REC); k++) {</span>
<span class="fc" id="L171">                        data[k] = readLongLoHi(bytes[i], bytes[i + 1], bytes[i + 2], bytes[i + 3]);</span>
<span class="fc" id="L172">                        i += 4;</span>
                    }
                } finally {
<span class="fc" id="L175">                    outputStream.close();</span>
                }
            } finally {
<span class="fc" id="L178">                inputStream.close();</span>
            }
<span class="nc" id="L180">        } catch (final IOException e) {</span>
<span class="nc" id="L181">            throw new IncorrectDataModelException(&quot;Cannot initialize static data structure from: &quot; +</span>
                    fileName + &quot;, exception=&quot; + e);
<span class="fc" id="L183">        }</span>
<span class="fc" id="L184">        LOG.info(&quot;DataModel: regions initialized, read {} bytes&quot;, total);</span>
<span class="fc" id="L185">    }</span>

    /**
     * Get number of territories.
     *
     * @return Number of territories.
     */
    int getNrTerritories() {
<span class="nc" id="L193">        return nrTerritories;</span>
    }

    /**
     * Get number of territory records (rectangles per territory).
     *
     * @return Number of rectangles per territory.
     */
    // TODO: Explain what territory records contain exactly.
    int getNrTerritoryRecords() {
<span class="fc" id="L203">        return nrTerritoryRecords;</span>
    }

    @SuppressWarnings(&quot;PointlessArithmeticExpression&quot;)
        // TODO: Explain what this does exactly, why not return a Point or Rectangle?
    int getLonMicroDegMin(final int territoryRecord) {
<span class="fc" id="L209">        return data[((territoryRecord * DATA_FIELDS_PER_REC) + POS_DATA_LON_MICRO_DEG_MIN)];</span>
    }

    int getLatMicroDegMin(final int territoryRecord) {
<span class="fc" id="L213">        return data[(territoryRecord * DATA_FIELDS_PER_REC) + POS_DATA_LAT_MICRO_DEG_MIN];</span>
    }

    int getLonMicroDegMax(final int territoryRecord) {
<span class="fc" id="L217">        return data[(territoryRecord * DATA_FIELDS_PER_REC) + POS_DATA_LON_MICRO_DEG_MAX];</span>
    }

    int getLatMicroDegMax(final int territoryRecord) {
<span class="fc" id="L221">        return data[(territoryRecord * DATA_FIELDS_PER_REC) + POS_DATA_LAT_MICRO_DEG_MAX];</span>
    }

    int getDataFlags(final int territoryRecord) {
<span class="fc" id="L225">        return data[(territoryRecord * DATA_FIELDS_PER_REC) + POS_DATA_DATA_FLAGS] &amp; MASK_DATA_DATA_FLAGS;</span>
    }

    // TODO: Explain what a &quot;div&quot; and &quot;smart div&quot; is and how you use, and why you need to use it.
    int getSmartDiv(final int territoryRecord) {
<span class="fc" id="L230">        return data[(territoryRecord * DATA_FIELDS_PER_REC) + POS_DATA_DATA_FLAGS] &gt;&gt; SHIFT_POS_DATA_SMART_DIV;</span>
    }

    // TODO: Explain what these methods do exactly.
    // Low-level routines for data access.
    @SuppressWarnings(&quot;PointlessArithmeticExpression&quot;)
    int getDataFirstRecord(final int territoryNumber) {
<span class="pc bpc" id="L237" title="3 of 6 branches missed.">        assert (0 &lt;= territoryNumber) &amp;&amp; (territoryNumber &lt;= Territory.AAA.getNumber());</span>
<span class="fc" id="L238">        return index[territoryNumber + POS_INDEX_FIRST_RECORD];</span>
    }

    int getDataLastRecord(final int territoryNumber) {
<span class="pc bpc" id="L242" title="3 of 6 branches missed.">        assert (0 &lt;= territoryNumber) &amp;&amp; (territoryNumber &lt;= Territory.AAA.getNumber());</span>
<span class="fc" id="L243">        return index[territoryNumber + POS_INDEX_LAST_RECORD] - 1;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>