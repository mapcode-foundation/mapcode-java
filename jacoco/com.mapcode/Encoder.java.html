<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Encoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Mapcode Java Library</a> &gt; <a href="index.source.html" class="el_package">com.mapcode</a> &gt; <span class="el_source">Encoder.java</span></div><h1>Encoder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2014-2016 Stichting Mapcode Foundation (http://www.mapcode.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.mapcode;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;

import static com.mapcode.Boundary.createFromTerritoryRecord;
import static com.mapcode.Common.*;

class Encoder {
<span class="fc" id="L31">    private static final Logger LOG = LoggerFactory.getLogger(Encoder.class);</span>

<span class="fc" id="L33">    private static final DataModel dataModel = DataModel.getInstance();</span>

<span class="nc" id="L35">    private Encoder() {</span>
        // Prevent instantiation.
<span class="nc" id="L37">    }</span>

    // ----------------------------------------------------------------------
    // Method called from public Java API.
    // ----------------------------------------------------------------------

    @Nonnull
    static List&lt;Mapcode&gt; encode(
            final double latDeg,
            final double lonDeg,
            @Nullable final Territory territory,
            final boolean stopWithOneResult) {

<span class="fc" id="L50">        return encode(latDeg, lonDeg, territory, stopWithOneResult, null);</span>
    }

    // ----------------------------------------------------------------------
    // Private methods.
    // ----------------------------------------------------------------------

<span class="fc" id="L57">    private final static char[] ENCODE_CHARS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'B', 'C', 'D', 'F',</span>
            'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z', 'A', 'E', 'U'};

    @Nonnull
    private static List&lt;Mapcode&gt; encode(final double argLatDeg, final double argLonDeg,
                                        @Nullable final Territory territory, final boolean limitToOneResult,
                                        @Nullable final Territory argStateOverride) {
<span class="fc" id="L64">        LOG.trace(&quot;encode: latDeg={}, lonDeg={}, territory={}, limitToOneResult={}&quot;,</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">                argLatDeg, argLonDeg, (territory == null) ? null : territory.name(), limitToOneResult);</span>

<span class="fc" id="L67">        final Point pointToEncode = Point.fromDeg(argLatDeg, argLonDeg);</span>

<span class="fc" id="L69">        final List&lt;Mapcode&gt; results = new ArrayList&lt;Mapcode&gt;();</span>

<span class="fc" id="L71">        int lastbasesubareaID = -1;</span>

<span class="fc bfc" id="L73" title="All 2 branches covered.">        final int firstNr = (territory != null) ? territory.getNumber() : 0;</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">        final int lastNr = (territory != null) ? territory.getNumber() : Territory.AAA.getNumber();</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">        for (int ccode = firstNr; ccode &lt;= lastNr; ccode++) {</span>

<span class="fc" id="L77">            final int uptoTerritoryRecord = dataModel.getDataLastRecord(ccode);</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">            if (!createFromTerritoryRecord(uptoTerritoryRecord).containsPoint(pointToEncode)) {</span>
<span class="fc" id="L79">                continue;</span>
            }
<span class="fc" id="L81">            final int fromTerritoryRecord = dataModel.getDataFirstRecord(ccode);</span>
<span class="fc" id="L82">            final Territory currentEncodeTerritory = Territory.fromNumber(ccode);</span>

<span class="fc bfc" id="L84" title="All 2 branches covered.">            for (int territoryRecord = fromTerritoryRecord; territoryRecord &lt;= uptoTerritoryRecord; territoryRecord++) {</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">                if (createFromTerritoryRecord(territoryRecord).containsPoint(pointToEncode)) {</span>
<span class="fc" id="L86">                    String mapcode = &quot;&quot;;</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">                    if (Data.isNameless(territoryRecord)) {</span>
<span class="fc" id="L88">                        mapcode = encodeNameless(pointToEncode, territoryRecord, fromTerritoryRecord);</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">                    } else if (Data.getTerritoryRecordType(territoryRecord) &gt; Data.TERRITORY_RECORD_TYPE_PIPE) {</span>
<span class="fc" id="L90">                        mapcode = encodeAutoHeader(pointToEncode, territoryRecord);</span>
<span class="fc bfc" id="L91" title="All 4 branches covered.">                    } else if ((territoryRecord == uptoTerritoryRecord) &amp;&amp; (currentEncodeTerritory.getParentTerritory() != null)) {</span>
<span class="fc" id="L92">                        results.addAll(encode(argLatDeg, argLonDeg, currentEncodeTerritory.getParentTerritory(), limitToOneResult,</span>
                                currentEncodeTerritory));
<span class="fc" id="L94">                        continue;</span>
<span class="fc bfc" id="L95" title="All 4 branches covered.">                    } else if (!Data.isRestricted(territoryRecord) || (lastbasesubareaID == fromTerritoryRecord)) {</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">                        if (Data.getCodex(territoryRecord) &lt; 54) {</span>
<span class="fc" id="L97">                            mapcode = encodeGrid(territoryRecord, pointToEncode);</span>
                        }
                    }

<span class="fc bfc" id="L101" title="All 2 branches covered.">                    if (mapcode.length() &gt; 4) {</span>
<span class="fc" id="L102">                        mapcode = aeuPack(mapcode, false);</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">                        final Territory encodeTerritory = (argStateOverride != null) ? argStateOverride : currentEncodeTerritory;</span>

                        // Create new result.
<span class="fc" id="L107">                        final Mapcode newResult = new Mapcode(mapcode, encodeTerritory);</span>

                        // The result should not be stored yet.
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">                        if (!results.contains(newResult)) {</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">                            if (limitToOneResult) {</span>
<span class="fc" id="L112">                                results.clear();</span>
                            }
<span class="fc" id="L114">                            results.add(newResult);</span>
                        } else {
<span class="nc" id="L116">                            LOG.error(&quot;encode: Duplicate results found, newResult={}, results={} items&quot;,</span>
<span class="nc" id="L117">                                    newResult.getCodeWithTerritory(), results.size());</span>
                        }

<span class="fc" id="L120">                        lastbasesubareaID = fromTerritoryRecord;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">                        if (limitToOneResult) {</span>
<span class="fc" id="L122">                            return results;</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L128">        LOG.trace(&quot;encode: results={} items&quot;, results.size());</span>
<span class="fc" id="L129">        LOG.trace(&quot;&quot;);</span>
<span class="fc" id="L130">        return results;</span>
    }

    private static String encodeExtension(final Point pointToEncode, final int extrax4, final int extray, final int dividerx4, final int dividery, final int ydirection) {
<span class="fc" id="L134">        int extraDigits = 8; // always generate 8 digits</span>

<span class="fc" id="L136">        double factorx = Point.MAX_PRECISION_FACTOR * dividerx4;</span>
<span class="fc" id="L137">        double factory = Point.MAX_PRECISION_FACTOR * dividery;</span>
<span class="fc" id="L138">        double valx = (Point.MAX_PRECISION_FACTOR * extrax4) + pointToEncode.getLonFraction();</span>
<span class="fc" id="L139">        double valy = (Point.MAX_PRECISION_FACTOR * extray) + (ydirection * pointToEncode.getLatFraction());</span>

<span class="fc" id="L141">        final StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L142">        sb.append('-');</span>

        while (true) {
<span class="fc" id="L145">            factorx /= 30;</span>
            //noinspection NumericCastThatLosesPrecision
<span class="fc" id="L147">            final int gx = (int) (valx / factorx);</span>

<span class="fc" id="L149">            factory /= 30;</span>
            //noinspection NumericCastThatLosesPrecision
<span class="fc" id="L151">            final int gy = (int) (valy / factory);</span>

<span class="fc" id="L153">            sb.append(ENCODE_CHARS[((gy / 5) * 5) + (gx / 6)]);</span>
<span class="fc" id="L154">            --extraDigits;</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">            if (extraDigits == 0) {</span>
<span class="nc" id="L156">                break;</span>
            }

<span class="fc" id="L159">            sb.append(ENCODE_CHARS[(((gy % 5) * 6) + (gx % 6))]);</span>
<span class="fc" id="L160">            --extraDigits;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">            if (extraDigits == 0) {</span>
<span class="fc" id="L162">                break;</span>
            }

<span class="fc" id="L165">            valx -= factorx * gx;</span>
<span class="fc" id="L166">            valy -= factory * gy;</span>
<span class="fc" id="L167">        }</span>
<span class="fc" id="L168">        return sb.toString();</span>
    }

    private static String encodeGrid(final int m, final Point pointToEncode) {
<span class="fc" id="L172">        int codexm = Data.getCodex(m);</span>
<span class="fc" id="L173">        final int orgcodex = codexm;</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (codexm == 21) {</span>
<span class="fc" id="L175">            codexm = 22;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        } else if (codexm == 14) {</span>
<span class="fc" id="L177">            codexm = 23;</span>
        }
<span class="fc" id="L179">        final int prelen = codexm / 10;</span>
<span class="fc" id="L180">        final int postlen = codexm % 10;</span>
        final int divx;
<span class="fc" id="L182">        int divy = dataModel.getSmartDiv(m);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (divy == 1) {</span>
<span class="fc" id="L184">            divx = xSide[prelen];</span>
<span class="fc" id="L185">            divy = ySide[prelen];</span>
        } else {
<span class="fc" id="L187">            divx = nc[prelen] / divy;</span>
        }

<span class="fc" id="L190">        final int minx = createFromTerritoryRecord(m).getLonMicroDegMin();</span>
<span class="fc" id="L191">        final int miny = createFromTerritoryRecord(m).getLatMicroDegMin();</span>
<span class="fc" id="L192">        final int maxx = createFromTerritoryRecord(m).getLonMicroDegMax();</span>
<span class="fc" id="L193">        final int maxy = createFromTerritoryRecord(m).getLatMicroDegMax();</span>

<span class="fc" id="L195">        final int ygridsize = (((maxy - miny) + divy) - 1) / divy;</span>
<span class="fc" id="L196">        int rely = pointToEncode.getLatMicroDeg() - miny;</span>
<span class="fc" id="L197">        rely = rely / ygridsize;</span>

<span class="fc" id="L199">        final int xgridsize = (((maxx - minx) + divx) - 1) / divx;</span>
<span class="fc" id="L200">        int x = pointToEncode.getLonMicroDeg();</span>
<span class="fc" id="L201">        int relx = x - minx;</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (relx &lt; 0) {</span>
<span class="fc" id="L203">            x += Point.MICRO_DEG_360;</span>
<span class="fc" id="L204">            relx += Point.MICRO_DEG_360;</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">        } else if (relx &gt;= Point.MICRO_DEG_360) {</span>
<span class="fc" id="L206">            x -= Point.MICRO_DEG_360;</span>
<span class="fc" id="L207">            relx -= Point.MICRO_DEG_360;</span>
        }
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (relx &lt; 0) {</span>
<span class="nc" id="L210">            return &quot;&quot;;</span>
        }
<span class="fc" id="L212">        relx = relx / xgridsize;</span>
<span class="pc bpc" id="L213" title="2 of 4 branches missed.">        if ((relx &gt;= divx) || (rely &gt;= divy)) {</span>
<span class="nc" id="L214">            return &quot;&quot;;</span>
        }

        final int v;
<span class="fc bfc" id="L218" title="All 4 branches covered.">        if ((divx != divy) &amp;&amp; (prelen &gt; 2)) {</span>
<span class="fc" id="L219">            v = encodeSixWide(relx, rely, divx, divy);</span>
        } else {
<span class="fc" id="L221">            v = ((relx * divy) + divy) - 1 - rely;</span>
        }

<span class="fc" id="L224">        String result = encodeBase31(v, prelen);</span>

<span class="pc bpc" id="L226" title="1 of 6 branches missed.">        if ((prelen == 4) &amp;&amp; (divx == 961) &amp;&amp; (divy == 961)) {</span>
<span class="fc" id="L227">            result = String.valueOf(result.charAt(0)) + result.charAt(2) + result.charAt(1) + result.charAt(3);</span>
        }

<span class="fc" id="L230">        rely = miny + (rely * ygridsize);</span>
<span class="fc" id="L231">        relx = minx + (relx * xgridsize);</span>

<span class="fc" id="L233">        final int dividery = ((ygridsize + ySide[postlen]) - 1) / ySide[postlen];</span>
<span class="fc" id="L234">        final int dividerx = ((xgridsize + xSide[postlen]) - 1) / xSide[postlen];</span>

<span class="fc" id="L236">        result += '.';</span>

<span class="fc" id="L238">        int difx = x - relx;</span>
<span class="fc" id="L239">        int dify = pointToEncode.getLatMicroDeg() - rely;</span>

<span class="fc" id="L241">        final int extrax = difx % dividerx;</span>
<span class="fc" id="L242">        final int extray = dify % dividery;</span>

<span class="fc" id="L244">        difx = difx / dividerx;</span>
<span class="fc" id="L245">        dify = dify / dividery;</span>

<span class="fc" id="L247">        dify = ySide[postlen] - 1 - dify;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (postlen == 3) {</span>
<span class="fc" id="L249">            result += encodeTriple(difx, dify);</span>
        } else {

<span class="fc" id="L252">            String postfix = encodeBase31(((difx) * ySide[postlen]) + dify, postlen);</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (postlen == 4) {</span>
<span class="fc" id="L254">                postfix = String.valueOf(postfix.charAt(0)) + postfix.charAt(2) + postfix.charAt(1) + postfix.charAt(3);</span>
            }
<span class="fc" id="L256">            result += postfix;</span>
        }

<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (orgcodex == 14) {</span>
<span class="fc" id="L260">            result = result.charAt(0) + &quot;.&quot; + result.charAt(1) + result.substring(3);</span>
        }

<span class="fc" id="L263">        result += encodeExtension(pointToEncode, extrax &lt;&lt; 2, extray, dividerx &lt;&lt; 2, dividery, 1); // grid</span>

<span class="fc" id="L265">        return Data.headerLetter(m) + result;</span>
    }

    private static String encodeAutoHeader(final Point pointToEncode, final int thisindex) {
<span class="fc" id="L269">        final StringBuilder autoheader_result = new StringBuilder();</span>
<span class="fc" id="L270">        final int codexm = Data.getCodex(thisindex);</span>
<span class="fc" id="L271">        int storageStart = 0;</span>

        // search back to first pipe star
<span class="fc" id="L274">        int firstindex = thisindex;</span>
<span class="pc bpc" id="L275" title="1 of 4 branches missed.">        while ((Data.getTerritoryRecordType(firstindex - 1) &gt; Data.TERRITORY_RECORD_TYPE_PIPE) &amp;&amp; (Data.getCodex(firstindex - 1) == codexm)) {</span>
<span class="fc" id="L276">            firstindex--;</span>
        }

<span class="fc" id="L279">        int i = firstindex;</span>
        while (true) {

<span class="fc" id="L282">            final int maxx = createFromTerritoryRecord(i).getLonMicroDegMax();</span>
<span class="fc" id="L283">            final int maxy = createFromTerritoryRecord(i).getLatMicroDegMax();</span>
<span class="fc" id="L284">            final int minx = createFromTerritoryRecord(i).getLonMicroDegMin();</span>
<span class="fc" id="L285">            final int miny = createFromTerritoryRecord(i).getLatMicroDegMin();</span>

<span class="fc" id="L287">            int h = ((maxy - miny) + 89) / 90;</span>
<span class="fc" id="L288">            final int xdiv = xDivider(miny, maxy);</span>
<span class="fc" id="L289">            int w = ((((maxx - minx) * 4) + xdiv) - 1) / xdiv;</span>

<span class="fc" id="L291">            h = 176 * (((h + 176) - 1) / 176);</span>
<span class="fc" id="L292">            w = 168 * (((w + 168) - 1) / 168);</span>

<span class="fc" id="L294">            int product = (w / 168) * (h / 176) * 961 * 31;</span>

<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (Data.getTerritoryRecordType(i) == Data.TERRITORY_RECORD_TYPE_PLUS) // plus pipe</span>
            {
<span class="fc bfc" id="L298" title="All 2 branches covered.">                final int goodRounder = (codexm &gt;= 23) ? (961 * 961 * 31) : (961 * 961);</span>
<span class="fc" id="L299">                product =</span>
                        ((((storageStart + product + goodRounder) - 1) / goodRounder) * goodRounder) - storageStart;
            }

<span class="fc bfc" id="L303" title="All 2 branches covered.">            if (i == thisindex) {</span>
<span class="fc" id="L304">                final int dividerx = (((maxx - minx) + w) - 1) / w;</span>
<span class="fc" id="L305">                final int vx = (pointToEncode.getLonMicroDeg() - minx) / dividerx;</span>
<span class="fc" id="L306">                final int extrax = (pointToEncode.getLonMicroDeg() - minx) % dividerx;</span>

<span class="fc" id="L308">                final int dividery = (((maxy - miny) + h) - 1) / h;</span>
<span class="fc" id="L309">                int vy = (maxy - pointToEncode.getLatMicroDeg()) / dividery;</span>
<span class="fc" id="L310">                int extray = (maxy - pointToEncode.getLatMicroDeg()) % dividery;</span>

<span class="fc" id="L312">                int value = (vx / 168) * (h / 176);</span>
<span class="fc bfc" id="L313" title="All 4 branches covered.">                if ((extray == 0) &amp;&amp; (pointToEncode.getLatFraction() &gt; 0)) {</span>
<span class="fc" id="L314">                    vy--;</span>
<span class="fc" id="L315">                    extray += dividery;</span>
                }
<span class="fc" id="L317">                value += (vy / 176);</span>

<span class="fc" id="L319">                final int codexlen = (codexm / 10) + (codexm % 10);</span>
<span class="fc" id="L320">                autoheader_result.append(encodeBase31((storageStart / (961 * 31)) + value, codexlen - 2));</span>
<span class="fc" id="L321">                autoheader_result.append('.');</span>
<span class="fc" id="L322">                autoheader_result.append(encodeTriple(vx % 168, vy % 176));</span>

<span class="fc" id="L324">                autoheader_result.append(</span>
<span class="fc" id="L325">                        encodeExtension(pointToEncode, extrax &lt;&lt; 2, extray, dividerx &lt;&lt; 2, dividery, -1)); // AutoHeader</span>
<span class="fc" id="L326">                return autoheader_result.toString();</span>
            }

<span class="fc" id="L329">            storageStart += product;</span>
<span class="fc" id="L330">            i++;</span>
<span class="fc" id="L331">        }</span>
    }

    // mid-level encode/decode
    private static String encodeNameless(final Point pointToEncode, final int index, final int firstcode)
    // returns &quot;&quot; in case of (argument) error
    {
<span class="fc" id="L338">        final int codexm = Data.getCodex(index);</span>
<span class="fc" id="L339">        final int codexlen = (codexm / 10) + (codexm % 10);</span>
<span class="fc" id="L340">        final int first_nameless_record = getFirstNamelessRecord(codexm, index, firstcode);</span>
<span class="fc" id="L341">        final int a = countCityCoordinatesForCountry(codexm, index, firstcode);</span>
<span class="fc" id="L342">        final int p = 31 / a;</span>
<span class="fc" id="L343">        final int r = 31 % a;</span>
<span class="fc" id="L344">        final int nrX = index - first_nameless_record;</span>

        int storage_offset;

<span class="fc bfc" id="L348" title="All 4 branches covered.">        if ((codexm != 21) &amp;&amp; (a &lt;= 31)) {</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">            storage_offset = ((nrX * p) + ((nrX &lt; r) ? nrX : r)) * (961 * 961);</span>
<span class="fc bfc" id="L350" title="All 4 branches covered.">        } else if ((codexm != 21) &amp;&amp; (a &lt; 62)) {</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">            if (nrX &lt; (62 - a)) {</span>
<span class="fc" id="L352">                storage_offset = nrX * 961 * 961;</span>
            } else {
<span class="fc" id="L354">                storage_offset = ((62 - a) + (((nrX - 62) + a) / 2)) * 961 * 961;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">                if (((nrX + a) &amp; 1) != 0) {</span>
<span class="fc" id="L356">                    storage_offset += 16 * 961 * 31;</span>
                }
            }
        } else {
<span class="fc bfc" id="L360" title="All 2 branches covered.">            final int basePower = (codexm == 21) ? (961 * 961) : (961 * 961 * 31);</span>
<span class="fc" id="L361">            int basePowerA = basePower / a;</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">            if (a == 62) {</span>
<span class="nc" id="L363">                basePowerA++;</span>
            } else {
<span class="fc" id="L365">                basePowerA = 961 * (basePowerA / 961);</span>
            }

<span class="fc" id="L368">            storage_offset = nrX * basePowerA;</span>
        }

<span class="fc" id="L371">        int side = dataModel.getSmartDiv(index);</span>
<span class="fc" id="L372">        final int orgSide = side;</span>
<span class="fc" id="L373">        int xSide = side;</span>

<span class="fc" id="L375">        final int maxy = createFromTerritoryRecord(index).getLatMicroDegMax();</span>
<span class="fc" id="L376">        final int minx = createFromTerritoryRecord(index).getLonMicroDegMin();</span>
<span class="fc" id="L377">        final int miny = createFromTerritoryRecord(index).getLatMicroDegMin();</span>

<span class="fc" id="L379">        final int dividerx4 = xDivider(miny, maxy);</span>
<span class="fc" id="L380">        final int xFracture = pointToEncode.getLonFraction() / 810000;</span>
<span class="fc" id="L381">        final int dminx = pointToEncode.getLonMicroDeg() - minx;</span>
<span class="fc" id="L382">        final int dx = ((4 * dminx) + xFracture) / dividerx4;</span>
<span class="fc" id="L383">        final int extrax4 = (4 * dminx) - (dx * dividerx4); // like modulus, but with floating point value</span>

<span class="fc" id="L385">        final int dividery = 90;</span>
<span class="fc" id="L386">        final int dmaxy = maxy - pointToEncode.getLatMicroDeg();</span>
<span class="fc" id="L387">        int dy = dmaxy / dividery;</span>
<span class="fc" id="L388">        int extray = dmaxy % dividery;</span>

<span class="fc bfc" id="L390" title="All 4 branches covered.">        if ((extray == 0) &amp;&amp; (pointToEncode.getLatFraction() &gt; 0)) {</span>
<span class="fc" id="L391">            dy--;</span>
<span class="fc" id="L392">            extray += dividery;</span>
        }

<span class="fc" id="L395">        int v = storage_offset;</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (Data.isSpecialShape(index)) {</span>
<span class="fc" id="L397">            xSide *= side;</span>
<span class="fc" id="L398">            side = 1 + ((maxy - miny) / 90);</span>
<span class="fc" id="L399">            xSide = xSide / side;</span>
<span class="fc" id="L400">            v += encodeSixWide(dx, side - 1 - dy, xSide, side);</span>
        } else {
<span class="fc" id="L402">            v += (dx * side) + dy;</span>
        }

<span class="fc" id="L405">        String result = encodeBase31(v, codexlen + 1);</span>

<span class="fc bfc" id="L407" title="All 2 branches covered.">        if (codexlen == 3) {</span>
<span class="fc" id="L408">            result = result.substring(0, 2) + '.' + result.substring(2);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">        } else if (codexlen == 4) {</span>
<span class="fc bfc" id="L410" title="All 8 branches covered.">            if ((codexm == 22) &amp;&amp; (a &lt; 62) &amp;&amp; (orgSide == 961) &amp;&amp; !Data.isSpecialShape(index)) {</span>
<span class="fc" id="L411">                result = result.substring(0, 2) + result.charAt(3) + result.charAt(2) + result.charAt(4);</span>
            }
<span class="fc bfc" id="L413" title="All 2 branches covered.">            if (codexm == 13) {</span>
<span class="fc" id="L414">                result = result.substring(0, 2) + '.' + result.substring(2);</span>
            } else {
<span class="fc" id="L416">                result = result.substring(0, 3) + '.' + result.substring(3);</span>
            }
        }
<span class="fc" id="L419">        result += encodeExtension(pointToEncode, extrax4, extray, dividerx4, dividery, -1); // for encodeNameless</span>

<span class="fc" id="L421">        return result;</span>
    }

    // add vowels to prevent all-digit mapcodes
    static String aeuPack(final String argStr, final boolean argShort) {
<span class="fc" id="L426">        String str = argStr;</span>
<span class="fc" id="L427">        int dotpos = -9;</span>
<span class="fc" id="L428">        int rlen = str.length();</span>
        int d;
<span class="fc" id="L430">        String rest = &quot;&quot;;</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">        for (d = 0; d &lt; rlen; d++) {</span>
<span class="fc bfc" id="L432" title="All 4 branches covered.">            if ((str.charAt(d) &lt; '0') || (str.charAt(d) &gt; '9')) // not digit?</span>
            {
<span class="pc bpc" id="L434" title="1 of 4 branches missed.">                if ((str.charAt(d) == '.') &amp;&amp; (dotpos &lt; 0)) // first dot?</span>
                {
<span class="fc" id="L436">                    dotpos = d;</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">                } else if (str.charAt(d) == '-') {</span>
<span class="fc" id="L438">                    rest = str.substring(d);</span>
<span class="fc" id="L439">                    str = str.substring(0, d);</span>
<span class="fc" id="L440">                    rlen = d;</span>
                } else {
<span class="fc" id="L442">                    return str; // not alldigit (or multiple dots)</span>
                }
            }
        }

<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if ((rlen - 2) &gt; dotpos) {</span>
            // does r have a dot, AND at least 2 chars after the dot?
<span class="fc bfc" id="L449" title="All 2 branches covered.">            if (argShort) { // use A only</span>
<span class="fc" id="L450">                final int v = ((((int) str.charAt(0)) - 48) * 100) + ((((int) str.charAt(rlen - 2)) - 48) * 10) + (((int) str.charAt(rlen - 1)) - 48);</span>
<span class="fc" id="L451">                return 'A' + str.substring(1, rlen - 2) + ENCODE_CHARS[v / 32] + ENCODE_CHARS[v % 32] + rest;</span>
            } else { // use A, E and U
<span class="fc" id="L453">                final int v = (((((int) str.charAt(rlen - 2)) - 48) * 10) + ((int) str.charAt(rlen - 1))) - 48;</span>
<span class="fc" id="L454">                str = str.substring(0, rlen - 2) + ENCODE_CHARS[31 + (v / 34)] + ENCODE_CHARS[v % 34];</span>
            }
        }
<span class="fc" id="L457">        return str + rest;</span>
    }

    private static String encodeBase31(final int argValue, final int argNrChars) {
<span class="fc" id="L461">        int value = argValue;</span>
<span class="fc" id="L462">        int nrChars = argNrChars;</span>
<span class="fc" id="L463">        final StringBuilder result = new StringBuilder();</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">        while (nrChars &gt; 0) {</span>
<span class="fc" id="L465">            nrChars--;</span>
<span class="fc" id="L466">            result.insert(0, ENCODE_CHARS[value % 31]);</span>
<span class="fc" id="L467">            value = value / 31;</span>
        }
<span class="fc" id="L469">        return result.toString();</span>
    }

    private static int encodeSixWide(final int x, final int y, final int width, final int height) {
        int d;
<span class="fc" id="L474">        int col = x / 6;</span>
<span class="fc" id="L475">        final int maxcol = (width - 4) / 6;</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">        if (col &gt;= maxcol) {</span>
<span class="fc" id="L477">            col = maxcol;</span>
<span class="fc" id="L478">            d = width - (maxcol * 6);</span>
        } else {
<span class="fc" id="L480">            d = 6;</span>
        }
<span class="fc" id="L482">        return ((height * 6 * col) + ((height - 1 - y) * d) + x) - (col * 6);</span>
    }

    private static String encodeTriple(final int difx, final int dify) {
<span class="fc bfc" id="L486" title="All 2 branches covered.">        if (dify &lt; (4 * 34)) {</span>
<span class="fc" id="L487">            return ENCODE_CHARS[((difx / 28) + (6 * (dify / 34)))] + encodeBase31(((difx % 28) * 34) + (dify % 34), 2);</span>
        } else {
<span class="fc" id="L489">            return ENCODE_CHARS[((difx / 24) + 24)] + encodeBase31((((difx % 24) * 40) + dify) - 136, 2);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>